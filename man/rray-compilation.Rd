% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compile.R
\name{rray-compilation}
\alias{rray-compilation}
\alias{rray_compile_expr}
\alias{rray_compile_body}
\title{Compile expressions on the fly}
\usage{
rray_compile_expr(expr, args = NULL, arg_types = "xt::rarray<double>",
  name = "rray_func", return = "xt::rarray<double>", dry_run = FALSE)

rray_compile_body(body, args = NULL, arg_types = "xt::rarray<double>",
  name = "rray_func", dry_run = FALSE)
}
\arguments{
\item{expr}{An expression to be run at the C++ level using arguments
specified in \code{args}. The result of the expression is assigned directly
to a contain of type \code{return}, and then returned as an R object.}

\item{args}{A character vector for the names of the arguments of the created
C++ function.}

\item{arg_types}{A character vector of the types of \code{args}. Should be length
1 or as long as \code{args} is.}

\item{name}{A single character for the name of the created C++ function.}

\item{return}{A single character for the container type of the
result.}

\item{dry_run}{A single logical specifying whether or not to actually compile
the function. If set to \code{TRUE}, the function is not compiled, and the code
that would be compiled is printed instead.}

\item{body}{A character vector containing the entire body of the resulting
function. It must include a call to \code{return} at the end and should return
an object that can be converted to a \code{SEXP} automatically by Rcpp.}
}
\description{
These functions allow you to compile more complex operations in C++
on the fly. This can result in massive speed and memory improvements.
}
\details{
rray operations are not as "lazy" as they could be.
They perform the operation in C++ and instantly return the result. Consider
the following set of operations:\preformatted{x + y + z
}

First, \code{x + y} is computed, then the result of that is added to \code{z}. This
is essentially identical to:\preformatted{temp <- x + y
temp + z
}

If we were able to pass the entire expression of \code{x + y + z} down to the
xtensor library at once, it would actually perform the entire expression
in 1 loop, with no temporary object created. This can result in incredible
speed improvements.

These compilation functions allow you to do just that by constructing a
C++ function containing \code{x + y + z} and compiling it on the fly.
}
\examples{

# Compile an expression at the cpp level, and
# return the function as "rray_func()"
rray_compile_expr(x + y / z, args = c("x", "y", "z"))

rray_func(1, 2, 3)

# Full support for broadcasting is there automatically
# but you have to check that the dimensions are
# broadcastable yourself! Otherwise R will crash!
rray_func(1, 2, matrix(1:5))

# -----------------------------------------------------------

# A function that adds 3 objects together, storing
# them as intermediate variables using `auto`.
# These intermediate variables don't hold the result
# of the operation, but instead hold efficient xexpressions
# and the full operation is only computed when the result
# is assigned to `res`.
body <- '
  auto res1 = x + y;
  auto res2 = res1 + z;
  xt::rarray<double> res = res2;
  return res;
'

rray_compile_body(
  body = body,
  args = c("x", "y", "z"),
  name = "custom_func"
)

custom_func(1, matrix(6:10), matrix(1:5))


}
