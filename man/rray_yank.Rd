% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/subset.R
\name{rray_yank}
\alias{rray_yank}
\alias{rray_yank<-}
\title{Get or set elements of an array by position}
\usage{
rray_yank(x, i)

rray_yank(x, i) <- value
}
\arguments{
\item{x}{A vector, matrix, array or rray.}

\item{i}{One of the following:
\itemize{
\item An integer vector specifying the positions of the elements to yank.
\item A 1D logical vector of length 1, or \code{rray_elems(x)}.
\item A logical with the same dimension as \code{x}.
}}

\item{value}{A 1D value to be assigned to the location yanked by \code{i}. It will
be cast to the type and length of \code{x} after being yanked by \code{i}.}
}
\description{
\code{rray_yank()} is the counterpart to \code{\link[=rray_extract]{rray_extract()}}. It extracts elements
from an array \emph{by position}. It \emph{always} drops dimensions
(unlike \code{\link[=rray_subset]{rray_subset()}}), and a 1D vector is always returned.
}
\details{
Dimension names are \emph{only} kept in the special case of calling \code{rray_yank()}
on a 1D object. Otherwise, the method of keeping them is not well defined.

\code{rray_yank()} works with base R objects.

\code{rray_yank()} is meant as a replacement for the traditional behavior of
\code{x[i]} since \code{[} for rray objects is much stricter. Separating this special
behavior into a different function is less surprising.
}
\examples{

x <- rray(10:17, c(2, 2, 2))

# Resulting dimension is always 1D
rray_yank(x, 1:3)

# With logical
rray_yank(x, FALSE)
rray_yank(x, rep(c(TRUE, FALSE), times = rray_elems(x) / 2))

# You can assign a 1D vector to these yanked selections
rray_yank(x, c(1, 3, 5)) <- 9

# Logicals with the same dim as `x`
# can also be used as a yank indexer
lgl <- rray(c(TRUE, FALSE), c(2, 2, 2))
rray_yank(x, lgl)

# And you can set elements in these locations
rray_yank(x, lgl) <- NA

}
\seealso{
Other rray subsetters: \code{\link{rray_slice}},
  \code{\link{rray_subset}}
}
\concept{rray subsetters}
